<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>injury reserves - admin</title>

  <style>
    :root{
      --bg0:#0b0c10;
      --bg1:#11131a;
      --panel: rgba(10,10,14,0.62);
      --stroke: rgba(255,255,255,0.12);
      --stroke2: rgba(255,255,255,0.08);
      --text: #f2f2f2;
      --muted: rgba(242,242,242,0.75);
      --red1:#DB2E2E;
      --red2:#b50728;
    }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 15% 0%, rgba(219,46,46,0.22), transparent 60%),
        radial-gradient(1100px 520px at 90% 20%, rgba(181,7,40,0.18), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height: 100vh;
    }

    .wrap{
      width: min(1200px, 94vw);
      margin: 22px auto;
      padding: 0 0 28px;
    }

    .header{
      border-radius: 22px;
      padding: 18px;
      background: rgba(15,16,22,0.55);
      border: 1px solid var(--stroke);
      box-shadow: 0 22px 70px rgba(0,0,0,0.60);
      backdrop-filter: blur(14px);
    }

    .title{
      font-size: 28px;
      font-weight: 750;
      margin: 0;
      letter-spacing: 0.2px;
    }

    .subtitle{
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
    }

    .panel{
      margin-top: 14px;
      border-radius: 22px;
      padding: 16px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
    }

    .top{
      display:flex;
      gap:12px;
      flex-wrap: wrap;
      align-items:end;
    }

    .hint{
      color: var(--muted);
      font-size: 12px;
      margin: 0 0 6px;
    }

    input, select, button{
      padding: 10px 12px;
      font-size: 14px;
      color: var(--text);
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,0.35);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    input:disabled{
      opacity: 0.75;
      cursor: not-allowed;
    }

    input:focus, select:focus{
      outline: none;
      box-shadow: 0 0 0 3px rgba(181,7,40,0.20), 0 10px 30px rgba(0,0,0,0.35);
    }

    button{
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    button.primary{
      background: linear-gradient(180deg, rgba(219,46,46,0.95), rgba(181,7,40,0.85));
      border-color: rgba(255,255,255,0.14);
      box-shadow: 0 0 0 2px rgba(181,7,40,0.18) inset, 0 18px 44px rgba(0,0,0,0.45);
    }

    button.ghost{
      background: rgba(0,0,0,0.28);
    }


    .smallbtn{
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 800;
      line-height: 1;
    }

    .small{
      color: var(--muted);
      font-size: 12px;
      margin-top: 10px;
      line-height: 1.4;
    }

    .msg{
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.35);
      border: 1px solid var(--stroke);
      display:none;
    }

    .msg.danger{
      border-color: rgba(255,90,90,0.40);
    }

    .table{
      margin-top: 14px;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,0.28);
      box-shadow: 0 16px 55px rgba(0,0,0,0.55);
    }

    .thead, .trow{
      display: grid;
      grid-template-columns:
        220px
        repeat(13, 70px)
        120px; /* remove */
      align-items: center;
    }

    .thead{
      position: sticky;
      top: 0;
      z-index: 2;
      background: linear-gradient(180deg, rgba(181,7,40,0.35), rgba(0,0,0,0.85));
      border-bottom: 1px solid var(--stroke2);
      backdrop-filter: blur(10px);
    }

    .th, .td{
      padding: 12px 10px;
      border-right: 1px solid var(--stroke2);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-size: 11px;
      color: rgba(242,242,242,0.85);
      font-weight: 750;
      white-space: nowrap;
    }

    .td{
      text-transform: none;
      letter-spacing: 0;
      font-size: 14px;
      color: var(--text);
      font-weight: 650;
      border-top: 1px solid var(--stroke2);
    }

    .thead .th:last-child, .trow .td:last-child{ border-right: none; }

    .trow:hover .td{
      filter: brightness(1.06);
    }

   .trow{
  position: relative;
}

/* race stripe */


/* keep content above the stripe */
.trow > .td{
  position: relative;
  z-index: 1;
}


    .trow::before{
      content:"";
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:6px;
      background: var(--rowcolor, transparent);
      border-radius: 6px 0 0 6px;
      pointer-events: none;
    }

    .trow::after{
  content: "";
  position: absolute;
  inset: 0;
  background: var(--rowcolor);
  opacity: 0.18;          /* strength of stripe */
  pointer-events: none;
  z-index: 0;
}

    .trow.hasColor{
      background: linear-gradient(90deg, rgba(255,255,255,0.06), rgba(0,0,0,0.0));
    }

    .namecell{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .chip{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.22);
      box-shadow: 0 10px 22px rgba(0,0,0,0.45);
      flex: 0 0 auto;
    }

    .statbox{
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 8px 8px;
      user-select: none;
      cursor: pointer;
      text-align: center;
      background: rgba(0,0,0,0.25);
    }

    .statlabel{
      font-size: 10px;
      color: var(--muted);
      margin-bottom: 2px;
      text-transform: uppercase;
      letter-spacing: 0.7px;
      font-weight: 800;
    }

    .statval{
      font-size: 16px;
      font-weight: 850;
      line-height: 1.1;
    }

    .removeBtn{
      width: 100%;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(0,0,0,0.30);
    }

    @media (max-width: 1100px){
      .table{ overflow-x: auto; }
      .thead, .trow{ min-width: 1250px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="header">
      <h1 class="title">admin game entry</h1>
      <div class="subtitle">click a stat to +1. shift+click to -1. derived stats auto-calc on save.</div>
    </div>

    <div class="panel">
      <div class="top">
        <div>
          <div class="hint">season</div>
          <input id="season" value="4" />
        </div>

        <div>
          <div class="hint">game</div>
          <input id="game" value="1" />
        </div>

        <div style="min-width: 220px;">
          <div class="hint">opp</div>
          <input id="opp" placeholder="OPP" />
        </div>

        <div>
          <div class="hint">opp colour</div>
          <input id="oppColor" type="color" value="#4B5563" />
            <!-- admin.html changes: add two color pickers and send them in pushLiveScore() -->

<!-- put this near "opp colour" -->
<div>
  <div class="hint">opp stripe 1</div>
  <input id="oppStripe1" type="color" value="#ffffff" />
</div>

<div>
  <div class="hint">opp stripe 2</div>
  <input id="oppStripe2" type="color" value="#9CA3AF" />
</div>

<div style="min-width: 170px;">
  <div class="hint">period</div>
  <select id="period" style="min-width: 170px;">
    <option value="1ST">1ST</option>
    <option value="2ND">2ND</option>
    <option value="3RD">3RD</option>
    <option value="4TH">4TH</option>
    <option value="OT">OT</option>
  </select>
</div>
        </div>

        <div>
          <div class="hint">type</div>
          <select id="type">
            <option value="REG">REG</option>
            <option value="PRE">PRE</option>
            <option value="FINAL">FINAL</option>
          </select>
        </div>
<div>
          <div class="hint">opp score</div>
          <input id="oppScore" value="0" />
          <div class="btnrow" style="display:flex; gap:8px; margin-top:8px;">
            <button class="ghost smallbtn" data-oppdelta="-1">-1</button>
            <button class="ghost smallbtn" data-oppdelta="1">+1</button>
            <button class="ghost smallbtn" data-oppdelta="2">+2</button>
            <button class="ghost smallbtn" data-oppdelta="3">+3</button>
          </div>
        </div>

        <div style="min-width: 260px;">
          <div class="hint">add player</div>
          <select id="playerSelect" style="min-width: 260px;">
            <option value="">select player...</option>
          </select>
        </div>

        <div style="min-width: 220px;">
          <div class="hint">or custom name</div>
          <input id="customName" placeholder="new player name" />
        </div>

        <button id="addPlayer" class="ghost">add</button>
        <button id="save" class="primary">save game</button>
      </div>

      <div class="small">
        click a stat to +1. shift+click to -1. fgm/fga/pts/reb/%/gsc are calculated automatically.
      </div>

      <div id="msg" class="msg"></div>

      <div class="table" id="table">
        <div class="thead" id="thead"></div>
        <div id="tbody"></div>
      </div>
    </div>
  </div>

<script>
  const API = "http://127.0.0.1:5001";

  const COMMON_PLAYERS = [
    "Daniel Monitto",
    "Lachlan Farley",
    "James Norrish",
    "Vince Tomasello",
    "Austin Thorneycroft",
    "Brooklyn Bulmer"
  ];

  // only common names
  const COLOR_MAP = {
    "Brooklyn Bulmer": "#5f99f5",
    "Daniel Monitto": "#ebc026",
    "Lachlan Farley": "#59dea2",
    "James Norrish": "#fc9219",
    "Vince Tomasello": "#63b010",
    "Austin Thorneycroft": "#8858e8",
  };
  // popup tracking (once per player per game)
const TEAM_COLOR = "#DB2E2E";
const MILESTONE_REACHED = {}; // name -> highest 10s reached

function postOverlayEvent({title, line, color=TEAM_COLOR, ttlMs=2500}) {
  fetch(API + "/api/overlay_event", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ title, line, color, ttlMs })
  }).catch(()=>{});
}

function checkAndPostMilestone(name, pts){
  const mil = Math.floor((pts || 0) / 10);
  const reached = MILESTONE_REACHED[name] || 0;
  if (mil > reached && mil > 0){
    MILESTONE_REACHED[name] = mil;
    postOverlayEvent({ title: name, line: `${mil*10} points`, ttlMs: 2500 });
  }
}

async function postCareerFtIfAvailable(name){
  try{
    const r = await fetch(API + "/api/player_career_ft?name=" + encodeURIComponent(name), { cache: "no-store" });
    if (!r.ok) return;
    const j = await r.json();
    if (j.pct === null || j.pct === undefined) return;
    postOverlayEvent({ title: name, line: `ft% (career): ${j.pct}%`, ttlMs: 1800 });
  }catch(_){}
}



// ---- extra popup logic ----
const POP_STATE = {
  // run tracking
  prevTeam: 0,
  prevOpp: 0,
  runPts: 0,
  lastRunShown: 0,

  // per-player: points within window + streaks
  bursts: {},          // name -> [{ts, pts}]
  lastBurstShown: {},  // name -> ts
  makeStreak: {},      // name -> int
  lastStreakShown: {}, // name -> int

  // team shooting window
  teamShots: [],       // [{ts, made}]
  lastTeamRunShown: "",
  lastTeamShootShown: "",

  // milestones / fouls
  flags: {}            // `${name}|key|val` -> true
};

function playerColor(name){
  return COLOR_MAP[name] || TEAM_COLOR;
}

function flagOnce(name, key, val){
  const k = `${name}|${key}|${val}`;
  if (POP_STATE.flags[k]) return false;
  POP_STATE.flags[k] = true;
  return true;
}

function maybeRunPopup(teamNow, oppNow){
  // reset if opponent scored/changed
  if (oppNow !== POP_STATE.prevOpp){
    POP_STATE.runPts = 0;
  }
  const inc = teamNow - POP_STATE.prevTeam;
  if (oppNow === POP_STATE.prevOpp && inc > 0){
    POP_STATE.runPts += inc;
  }
  POP_STATE.prevTeam = teamNow;
  POP_STATE.prevOpp = oppNow;

  // trigger at 6+ (feel free to change)
  if (POP_STATE.runPts >= 6 && POP_STATE.runPts !== POP_STATE.lastRunShown){
    POP_STATE.lastRunShown = POP_STATE.runPts;
    postOverlayEvent({
      title: "inj",
      line: `${POP_STATE.runPts}â€“0 run`,
      color: TEAM_COLOR,
      ttlMs: 2400
    });
  }
}

function recordShotForTeam(made){ /* disabled */ }

function recordMakeForPlayer(name, ptsDelta){
  const now = Date.now();
  // burst window (90s)
  const arr = (POP_STATE.bursts[name] ||= []);
  arr.push({ ts: now, pts: ptsDelta });
  const cutoff = now - 90_000;
  while (arr.length && arr[0].ts < cutoff) arr.shift();
  const sum = arr.reduce((a,e)=>a+e.pts,0);

  if (sum >= 6){
    const last = POP_STATE.lastBurstShown[name] || 0;
    // cool-down 30s to avoid spam
    if (now - last > 30_000){
      POP_STATE.lastBurstShown[name] = now;
      postOverlayEvent({
        title: name,
        line: `${sum} points (last 90s)`,
        color: playerColor(name),
        ttlMs: 2400
      });
    }
  }

  // make streak (resets on a miss via attempts)
  POP_STATE.makeStreak[name] = (POP_STATE.makeStreak[name] || 0) + 1;
  const streak = POP_STATE.makeStreak[name];
  if (streak >= 3){
    const shown = POP_STATE.lastStreakShown[name] || 0;
    if (streak > shown){
      POP_STATE.lastStreakShown[name] = streak;
      postOverlayEvent({
        title: name,
        line: `${streak} straight makes`,
        color: playerColor(name),
        ttlMs: 2200
      });
    }
  }
}

function recordMissForPlayer(name){
  POP_STATE.makeStreak[name] = 0;
}

function checkOtherMilestones(p){
  const name = p.NAMES;

  // rebounds
  const reb = p.REB || 0;
  if (reb >= 5 && flagOnce(name,"reb",5)) postOverlayEvent({ title: name, line: "5 rebounds", color: playerColor(name), ttlMs: 2000 });
  if (reb >= 10 && flagOnce(name,"reb",10)) postOverlayEvent({ title: name, line: "10 rebounds", color: playerColor(name), ttlMs: 2200 });

  // assists
  const ast = p.AST || 0;
  if (ast >= 5 && flagOnce(name,"ast",5)) postOverlayEvent({ title: name, line: "5 assists", color: playerColor(name), ttlMs: 2000 });
  if (ast >= 10 && flagOnce(name,"ast",10)) postOverlayEvent({ title: name, line: "10 assists", color: playerColor(name), ttlMs: 2200 });

  // foul trouble (individual only)
  const fls = p.FLS || 0;
  if (fls >= 3 && flagOnce(name,"fls",3)) postOverlayEvent({ title: name, line: "3 fouls", color: playerColor(name), ttlMs: 2200 });
  if (fls >= 4 && flagOnce(name,"fls",4)) postOverlayEvent({ title: name, line: "4 fouls", color: playerColor(name), ttlMs: 2200 });
  if (fls >= 5 && flagOnce(name,"fls",5)) postOverlayEvent({ title: name, line: "5 fouls FOULED OUT", color: playerColor(name), ttlMs: 2400 });

  // double/triple/quadruple-double tracking (pts, reb, ast, stl, blk)
  const pts = p.PTS || 0;
  const stl = p.STL || 0;
  const blk = p.BLK || 0;
  const fgPct = Math.round(((p["FG%"] || 0) * 100));

  // counts across 5 categories for doubles
  const watchCount =
    (pts>=8) + (reb>=8) + (ast>=8) + (stl>=8) + (blk>=8);

  const doneCount =
    (pts>=10) + (reb>=10) + (ast>=10) + (stl>=10) + (blk>=10);

  // always show full line on watch/achieved
  const statLine = `${pts}p ${reb}r ${ast}a ${stl}s ${blk}b fg ${fgPct}%`;

  // watch popups (only once per level)
  if (watchCount >= 4 && flagOnce(name,"qd_watch",1)){
    postOverlayEvent({ title: name, line: `quadruple-double watch: ${statLine}`, color: playerColor(name), ttlMs: 3000 });
  } else if (watchCount === 3 && flagOnce(name,"td_watch",1)){
    postOverlayEvent({ title: name, line: `triple-double watch: ${statLine}`, color: playerColor(name), ttlMs: 2800 });
  } else if (watchCount === 2 && flagOnce(name,"dd_watch",1)){
    postOverlayEvent({ title: name, line: `double-double watch: ${statLine}`, color: playerColor(name), ttlMs: 2600 });
  }

  // achieved popups (only once per level)
  if (doneCount >= 4 && flagOnce(name,"qd",1)){
    postOverlayEvent({ title: name, line: `quadruple-double: ${statLine}`, color: playerColor(name), ttlMs: 3400 });
  } else if (doneCount === 3 && flagOnce(name,"td",1)){
    postOverlayEvent({ title: name, line: `triple-double: ${statLine}`, color: playerColor(name), ttlMs: 3200 });
  } else if (doneCount === 2 && flagOnce(name,"dd",1)){
    postOverlayEvent({ title: name, line: `double-double: ${statLine}`, color: playerColor(name), ttlMs: 2800 });
  }
}

function pushLiveScore() {
  let team = 0;
  state.players.forEach(p => team += p.PTS || 0);

  const opp = Number(document.getElementById("oppScore").value || 0);
  const period = document.getElementById("period").value;

  // run detection (team points while opp unchanged)
  maybeRunPopup(team, opp);

  // convert hex -> rgba strings (so scoreboard can use alpha if you want later)
  const s1 = document.getElementById("oppStripe1")?.value || "#ffffff";
  const s2 = document.getElementById("oppStripe2")?.value || "#9CA3AF";

  fetch(API + "/api/live_score", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({
      home: team,
      away: opp,
      opp: document.getElementById("opp").value || "OPP",
      oppColor: document.getElementById("oppColor").value || "#4B5563",
      period: period,

      // new stripe fields (hex is fine; css accepts it)
      oppStripe1: s1,
      oppStripe2: s2
    })
  });
}
// also add listeners so it updates live:





  const EDITABLE = [
    ["2PM","2pm"], ["2PA","2pa"], ["3PM","3pm"], ["3PA","3pa"],
    ["FTM","ftm"], ["FTA","fta"],
    ["OREB","oreb"], ["DREB","dreb"],
    ["AST","ast"], ["STL","stl"], ["BLK","blk"],
    ["TOV","tov"], ["FLS","fls"]
  ];

  const clamp0 = (n) => Math.max(0, n|0);

  function pct(m, a) { return a ? (m / a) : 0; }

  function calcGSC(p) {
    const PTS = p.PTS, FG = p.FGM, FGA = p.FGA, FT = p.FTM, FTA = p.FTA;
    const ORB = p.OREB, DRB = p.DREB, STL = p.STL, AST = p.AST, BLK = p.BLK;
    const PF = p.FLS, TOV = p.TOV;
    return (
      PTS + 0.4*FG - 0.7*FGA - 0.4*(FTA-FT) + 0.7*ORB + 0.3*DRB + STL +
      0.7*AST + 0.7*BLK - 0.4*PF - TOV
    );
  }

  function derive(p) {
    for (const [k] of EDITABLE) p[k] = clamp0(p[k] || 0);

    p.FGM = p["2PM"] + p["3PM"];
    p.FGA = p["2PA"] + p["3PA"];
    p.REB = p.OREB + p.DREB;
    p.PTS = 2*p["2PM"] + 3*p["3PM"] + p.FTM;

    p["2P%"] = pct(p["2PM"], p["2PA"]);
    p["3P%"] = pct(p["3PM"], p["3PA"]);
    p["FT%"] = pct(p.FTM, p.FTA);
    p["FG%"] = pct(p.FGM, p.FGA);
    const denom = 2 * (p.FGA + 0.44 * p.FTA);
    p["TS%"] = denom ? (p.PTS / denom) : 0;

    p.GSC = calcGSC(p);
    return p;
  }

  function newPlayer(name) {
    return derive({
      NAMES: name,
      "2PM":0,"2PA":0,"3PM":0,"3PA":0,
      FTM:0,FTA:0, OREB:0,DREB:0,
      AST:0,STL:0,BLK:0,TOV:0,FLS:0,
      FGM:0,FGA:0,PTS:0,REB:0,
      "FG%":0,"TS%":0,"FT%":0,"2P%":0,"3P%":0,
      GSC:0
    });
  }

  let state = { players: [] };

  function showMsg(s, ok=true) {
    const el = document.getElementById("msg");
    el.style.display = "block";
    el.textContent = s;
    el.className = "msg" + (ok ? "" : " danger");
  }

  function renderHeader() {
    const head = document.getElementById("thead");
    head.innerHTML = "";

    const thName = document.createElement("div");
    thName.className = "th";
    thName.textContent = "player";
    head.appendChild(thName);

    for (const [,label] of EDITABLE) {
      const th = document.createElement("div");
      th.className = "th";
      th.textContent = label;
      head.appendChild(th);
    }

    const thRemove = document.createElement("div");
    thRemove.className = "th";
    thRemove.textContent = "";
    head.appendChild(thRemove);
  }

  function renderRows() {
    const body = document.getElementById("tbody");
    body.innerHTML = "";

    state.players.forEach((p, idx) => {
      derive(p);

      const row = document.createElement("div");
      row.className = "trow";

      // name cell with color chip + row strip (only for mapped names)
      const name = document.createElement("div");
      name.className = "td namecell";

      const chip = document.createElement("div");
      chip.className = "chip";

      const c = COLOR_MAP[p.NAMES];
      if (c) row.style.setProperty("--rowcolor", c);
      if (c) {
        row.classList.add("hasColor");
        row.style.setProperty("--rowcolor", c);
        row.style.borderLeft = "6px solid " + c;
        row.style.background = "linear-gradient(90deg, " + c + "22 0%, rgba(0,0,0,0) 22%)";
        chip.style.background = c;
      } else {
        chip.style.background = "rgba(255,255,255,0.25)";
        chip.style.opacity = "0.8";
      }

      const label = document.createElement("div");
      label.textContent = p.NAMES;

      name.appendChild(chip);
      name.appendChild(label);
      row.appendChild(name);

      for (const [key,labelTxt] of EDITABLE) {
        const cell = document.createElement("div");
        cell.className = "td";

        const box = document.createElement("div");
        box.className = "statbox";
        
        box.onclick = async (e) => {
          const delta = e.shiftKey ? -1 : 1;

          // before change
          const before = derive({...p});

          // apply
          p[key] = clamp0((p[key] || 0) + delta);
          derive(p);

          // render + push live score
          renderRows();
          pushLiveScore();

          // points milestones (10s)
          checkAndPostMilestone(p.NAMES, p.PTS || 0);

          // other milestones + fouls + dd watch
          checkOtherMilestones(p);

          // shot/run/streak logic (based on clicks)
          if (delta === 1){
            if (key === "2PM"){ recordMakeForPlayer(p.NAMES, 2); recordShotForTeam(true); }
            if (key === "3PM"){ recordMakeForPlayer(p.NAMES, 3); recordShotForTeam(true); }
            if (key === "FTM"){ recordMakeForPlayer(p.NAMES, 1); }
            if (key === "2PA" || key === "3PA"){ recordMissForPlayer(p.NAMES); recordShotForTeam(false); }
          }

          // career ft% popup when increasing fta
          if (key === "FTA" && delta === 1){
            await postCareerFtIfAvailable(p.NAMES);
          }
        };



        const l = document.createElement("div");
        l.className = "statlabel";
        l.textContent = labelTxt;

        const v = document.createElement("div");
        v.className = "statval";
        v.textContent = String(p[key] || 0);

        box.appendChild(l);
        box.appendChild(v);
        cell.appendChild(box);
        row.appendChild(cell);
      }

      const rm = document.createElement("div");
      rm.className = "td";
      const btn = document.createElement("button");
      btn.className = "removeBtn";
      btn.textContent = "remove";
      btn.onclick = () => {
        state.players.splice(idx, 1);
        renderRows();
        pushLiveScore();
      };

      rm.appendChild(btn);
      row.appendChild(rm);

      body.appendChild(row);
    });
  }



  function render() {
    renderHeader();
    renderRows();
  }

  function initPlayersDropdown() {
    const sel = document.getElementById("playerSelect");
    COMMON_PLAYERS.forEach(n => {
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    });
  }

  document.getElementById("addPlayer").onclick = () => {
    const sel = document.getElementById("playerSelect");
    const picked = sel.value.trim();
    const custom = document.getElementById("customName").value.trim();
    const name = custom || picked;

    if (!name) return;

    const exists = state.players.some(p => p.NAMES.toLowerCase() === name.toLowerCase());
    if (exists) {
      showMsg("player already added", false);
      return;
    }

    state.players.push(newPlayer(name));
    document.getElementById("customName").value = "";
    sel.value = "";
    renderRows();
    pushLiveScore();
  };

  document.getElementById("save").onclick = async () => {
    const season = document.getElementById("season").value.trim();
    const game = document.getElementById("game").value.trim();
    const opp = document.getElementById("opp").value.trim();
    const type = document.getElementById("type").value;

    if (!season || !game || !opp) {
      showMsg("season/game/opp required", false);
      return;
    }
    if (!state.players.length) {
      showMsg("add at least one player", false);
      return;
    }

    const players = state.players.map(p => derive({...p}));
    const oppScore = Number(document.getElementById("oppScore").value || 0);

    const payload = {
      meta: {
        season: Number(season),
        game: Number(game),
        opp,
        type,
        oppScore,
        oppColor: document.getElementById("oppColor").value || ""
      },
      players
    };

    try {
      const res = await fetch(API + "/api/save_game", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const js = await res.json();
      if (!res.ok) throw new Error(js.error || "save failed");
      showMsg(`saved: ${js.inserted} rows`);
    } catch (err) {
      showMsg(String(err), false);
    }
  };

  initPlayersDropdown();
  render();
  document.getElementById("oppScore").addEventListener("input", pushLiveScore);
  document.getElementById("opp").addEventListener("input", pushLiveScore);
  document.getElementById("oppColor").addEventListener("input", pushLiveScore);
  document.getElementById("oppStripe1").addEventListener("input", pushLiveScore);
  document.getElementById("oppStripe2").addEventListener("input", pushLiveScore);
  document.getElementById("period").addEventListener("change", pushLiveScore);

  // quick +/- buttons for opp score (1/2/3)
  document.querySelectorAll("[data-oppdelta]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      const d = Number(btn.getAttribute("data-oppdelta") || 0);
      const inp = document.getElementById("oppScore");
      const cur = Number(inp.value || 0);
      inp.value = String(Math.max(0, cur + d));
      pushLiveScore();
    });
  });

</script>
</body>
</html>
