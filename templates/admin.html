<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>injury reserves - admin</title>

  <style>
    :root{
      --bg0:#0b0c10;
      --bg1:#11131a;
      --panel: rgba(10,10,14,0.62);
      --stroke: rgba(255,255,255,0.12);
      --stroke2: rgba(255,255,255,0.08);
      --text: #f2f2f2;
      --muted: rgba(242,242,242,0.75);
      --red1:#DB2E2E;
      --red2:#b50728;
    }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 15% 0%, rgba(219,46,46,0.22), transparent 60%),
        radial-gradient(1100px 520px at 90% 20%, rgba(181,7,40,0.18), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height: 100vh;
    }

    .wrap {
  width: 98vw;
  max-width: 1600px;
  margin: 22px auto;
  padding: 0 0 28px;
}

.header {
  border-radius: 22px;
  padding: 18px;
  background: rgba(15, 16, 22, 0.55);
  border: 1px solid var(--stroke);
  box-shadow: 0 22px 70px rgba(0, 0, 0, 0.60);
  backdrop-filter: blur(14px);
}


      .title {
        font-size: 28px;
        font-weight: 750;
        margin: 0;
        letter-spacing: 0.2px;
      }

      .subtitle {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 13px;
      }

      .panel {
        margin-top: 14px;
        border-radius: 22px;
        padding: 16px;
        background: var(--panel);
        border: 1px solid var(--stroke);
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(14px);
      }

      .top {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: end;
      }

      .hint {
        color: var(--muted);
        font-size: 12px;
        margin: 0 0 6px;
      }

      input, select, button {
        padding: 10px 12px;
        font-size: 14px;
        color: var(--text);
        border-radius: 14px;
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.35);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      input:disabled {
        opacity: 0.75;
        cursor: not-allowed;
      }

      input:focus, select:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(181, 7, 40, 0.20), 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      button {
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      button.primary {
        background: linear-gradient(180deg, rgba(219, 46, 46, 0.95), rgba(181, 7, 40, 0.85));
        border-color: rgba(255, 255, 255, 0.14);
        box-shadow: 0 0 0 2px rgba(181, 7, 40, 0.18) inset, 0 18px 44px rgba(0, 0, 0, 0.45);
      }

      button.ghost {
        background: rgba(0, 0, 0, 0.28);
      }

      .smallbtn {
        padding: 8px 10px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 800;
        line-height: 1;
      }

      .small {
        color: var(--muted);
        font-size: 12px;
        margin-top: 10px;
        line-height: 1.4;
      }

      .msg {
        margin-top: 12px;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid var(--stroke);
        display: none;
      }

      .msg.danger {
        border-color: rgba(255, 90, 90, 0.40);
      }

      .table {
        margin-top: 14px;
        overflow: auto;
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.28);
        box-shadow: 0 16px 55px rgba(0, 0, 0, 0.55);
      }

      .thead, .trow {
  display: grid;
grid-template-columns:
  80px
  repeat(13, minmax(44px, 1fr))
  60px
  90px
        32px;
  align-items: center;
}



      .thead {
        position: sticky;
        top: 0;
        z-index: 2;
        background: linear-gradient(180deg, rgba(181, 7, 40, 0.35), rgba(0, 0, 0, 0.85));
        border-bottom: 1px solid var(--stroke2);
        backdrop-filter: blur(10px);
      }

      .th, .td {
        padding: 8px 8px;
        border-right: 1px solid var(--stroke2);
        text-transform: uppercase;
        letter-spacing: 0.8px;
        font-size: 11px;
        color: rgba(242, 242, 242, 0.85);
        font-weight: 750;
        white-space: nowrap;
        text-align: center;

      }

      .td {
        text-transform: none;
        letter-spacing: 0;
        font-size: 14px;
        color: var(--text);
        font-weight: 650;
        border-top: 1px solid var(--stroke2);
      }

      .thead .th:last-child,
.trow .td:last-child {
  text-align: center;
}


      .trow {
        position: relative;
      }

      .trow > .td {
        position: relative;
        z-index: 1;
      }

      .trow::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 6px;
        background: var(--rowcolor, transparent);
        border-radius: 6px 0 0 6px;
        pointer-events: none;
      }

      .trow::after {
        content: "";
        position: absolute;
        inset: 0;
        background: var(--rowcolor);
        opacity: 0.18;
        pointer-events: none;
        z-index: 0;
      }

      .trow.hasColor {
        background: linear-gradient(90deg, rgba(255, 255, 255, 0.06), rgba(0, 0, 0, 0.0));
      }

      .namecell {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  font-weight: 800;
}


      .statbox {
        border: 1px solid rgba(255, 255, 255, 0.10);
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.04);
        transition: all 0.15s ease;
        width: 100%;
        padding: 6px 4px;
      }

      .statbox:hover {
        background: rgba(255, 255, 255, 0.08);
        transform: translateY(-1px);
      }


      .statbox.readonly {
        cursor: default;
        opacity: 0.92;
        background: rgba(0, 0, 0, 0.18);
      }

      .statlabel {
        font-size: 9px;
        color: var(--muted);
        margin-bottom: 2px;
        text-transform: uppercase;
        letter-spacing: 0.7px;
        font-weight: 800;
      }

      .statval {
        font-size: 14px;
        font-weight: 850;
        line-height: 1.1;
      }

.removeBtn {
  background: none;
  border: none;
  color: rgba(255,255,255,0.6);
  font-size: 16px;
  font-weight: 900;
  padding: 0;
  line-height: 1;
  cursor: pointer;
  display: block;
  margin: 0 auto;
}



.removeBtn:hover {
  color: #ff6b6b;
  transform: scale(1.1);
}



      .td.min,
      .td.pm {
        font-variant-numeric: tabular-nums;
        font-weight: 800;
        text-align: center;
        letter-spacing: 0.5px;
      }

      .td.pm {
        font-size: 15px;
      }

      .td.pm.pos {
        color: #5fe18b;
      }

      .td.pm.neg {
        color: #ff6b6b;
      }

      .lineupControls {
        display: flex;
        gap: 6px;
        justify-content: center;
      }

      .lineupControls button {
        padding: 6px 8px;
        font-size: 11px;
        font-weight: 800;
        border-radius: 10px;
      }

      .lineupControls button.inActive {
        background: #1f6b3b;
        border-color: #2dbf6b;
      }

      .lineupControls button.outActive {
        background: #7a2020;
        border-color: #ff6b6b;
      }

      .trow.active {
        box-shadow: inset 0 0 0 2px rgba(95, 225, 139, 0.6);
      }

      .clockBtn.active {
  background: linear-gradient(180deg, #1f6b3b, #14532d);
  border-color: #2dbf6b;
  box-shadow: 0 0 0 2px rgba(45,191,107,0.35) inset;
}

.clockBtn.stopActive {
  background: linear-gradient(180deg, #7a2020, #4c1010);
  border-color: #ff6b6b;
  box-shadow: 0 0 0 2px rgba(255,107,107,0.35) inset;
}

.thead .th:first-child,
.trow .td:first-child {
  text-align: center;
}




      @media (max-width: 1100px) {
        .table {
          overflow-x: auto;
        }
      }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="header">
      <h1 class="title">admin game entry</h1>
      <div class="subtitle">click a stat to +1. shift+click to -1. derived stats auto-calc on save.</div>
    </div>

    <div class="panel">
      <div class="top">
        <div>
          <div class="hint">season</div>
          <input id="season" value="4" />

        </div>

        <div>
          <div class="hint">game</div>
          <input id="game" value="1" />
        </div>

        <div style="min-width: 220px;">
          <div class="hint">opp</div>
          <input id="opp" placeholder="OPP" />
        </div>

        <div>
          <div class="hint">opp colour</div>
          <input id="oppColor" type="color" value="#4B5563" />
        </div>

        <div>
          <div class="hint">opp stripe 1</div>
          <input id="oppStripe1" type="color" value="#ffffff" />
        </div>

        <div>
          <div class="hint">opp stripe 2</div>
          <input id="oppStripe2" type="color" value="#9CA3AF" />
        </div>

        <div style="min-width: 170px;">
          <div class="hint">period</div>
          <select id="period" style="min-width: 170px;">
            <option value="1ST">1ST</option>
            <option value="2ND">2ND</option>
            <option value="3RD">3RD</option>
            <option value="4TH">4TH</option>
            <option value="OT">OT</option>
          </select>
        </div>

        <div>
          <div class="hint">type</div>
          <select id="type">
            <option value="REG">REG</option>
            <option value="PRE">PRE</option>
            <option value="FINAL">FINAL</option>
          </select>
        </div>


        <div style="min-width: 260px;">
          <div class="hint">add player</div>
          <select id="playerSelect" style="min-width: 260px;">
            <option value="">select player...</option>
          </select>
        </div>

        <div style="min-width: 220px;">
          <div class="hint">or custom name</div>
          <input id="customName" placeholder="new player name" />
        </div>

        <button id="addPlayer" class="ghost">add</button>
        <button id="save" class="primary">save game</button>
          <button id="reset" class="ghost">reset</button>
        <div style="flex-basis: 100%; height: 0;"></div>
         <button id="startBtn" class="ghost clockBtn" onclick="startClock()">start</button>
        <button id="stopBtn" class="ghost clockBtn" onclick="stopClock()">stop</button>
                    <button class="ghost smallbtn" data-oppdelta="-1">-1</button>
            <button class="ghost smallbtn" data-oppdelta="1">+1</button>
            <button class="ghost smallbtn" data-oppdelta="2">+2</button>
            <button class="ghost smallbtn" data-oppdelta="3">+3</button>
        <div class="hint">opp score</div>
          <input id="oppScore" value="0" />
          <div class="btnrow" style="display:flex; gap:8px; margin-top:8px;">
          </div>
        <button id="undo" class="ghost">undo</button>

      </div>

      <div class="small">
        click a stat to +1. shift+click to -1. fgm/fga/pts/reb/%/gsc are calculated automatically.
      </div>

      <div id="msg" class="msg"></div>

      <div class="table" id="table">
        <div class="thead" id="thead"></div>
        <div id="tbody"></div>
      </div>
    </div>
  </div>


  <dialog id="cfgDlg" style="border:none; border-radius:18px; padding:0; background: rgba(15,16,22,0.95); color: var(--text); width:min(520px, 92vw); box-shadow: 0 30px 90px rgba(0,0,0,0.75);">
    <form method="dialog" style="padding:16px; border:1px solid var(--stroke); border-radius:18px;">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px;">
        <div style="font-weight:800; letter-spacing:0.3px;">scoreboard config</div>
        <button id="cfgClose" class="ghost smallbtn" value="cancel" type="submit">close</button>
      </div>

      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
        <div>
          <div class="hint">run popup threshold</div>
          <input id="cfgRunThreshold" type="number" min="2" max="30" step="1" value="6" />
        </div>

        <div>
          <div class="hint">stripe gap (px)</div>
          <input id="cfgStripeGap" type="number" min="0" max="30" step="1" value="5" />
        </div>

        <div>
          <div class="hint">stripe shadow (alpha)</div>
          <input id="cfgStripeShadowAlpha" type="number" min="0" max="1" step="0.02" value="0.28" />
        </div>

        <div>
          <div class="hint">border (alpha)</div>
          <input id="cfgStrokeAlpha" type="number" min="0" max="1" step="0.02" value="0.18" />
        </div>
      </div>

      <div style="display:flex; gap:10px; margin-top:14px; justify-content:flex-end;">
        <button id="cfgReset" class="ghost" type="button">defaults</button>
        <button id="cfgSave" class="primary" type="button">save</button>
      </div>

      <div class="small" style="margin-top:10px;">
        saved locally in this browser. sent to scoreboard automatically while you enter stats.
      </div>
    </form>
  </dialog>

<script>
  const API = "http://127.0.0.1:5001";

  const COMMON_PLAYERS = [
    "Daniel Monitto",
    "Lachlan Farley",
    "James Norrish",
    "Vince Tomasello",
    "Austin Thorneycroft",
    "Brooklyn Bulmer",
    "Aidan Zivkovic"
  ];


  const COLOR_MAP = {
    "Brooklyn Bulmer": "#5f99f5",
    "Daniel Monitto": "#ebc026",
    "Lachlan Farley": "#59dea2",
    "James Norrish": "#fc9219",
    "Vince Tomasello": "#63b010",
    "Austin Thorneycroft": "#8858e8",
    "Aidan Zivkovic": "#d651b3",
  };

  const TEAM_COLOR = "#DB2E2E";
  const MILESTONE_REACHED = {};
  const DEFAULT_CFG = {
    runThreshold: 6,
    stripeGap: 5,
    stripeShadowAlpha: 0.28,
    strokeAlpha: 0.18
  };

  function loadCfg(){
    try{
      const raw = localStorage.getItem("ir_config");
      if (!raw) return {...DEFAULT_CFG};
      const j = JSON.parse(raw);
      return {...DEFAULT_CFG, ...j};
    }catch(_){
      return {...DEFAULT_CFG};
    }
  }

  function saveCfg(cfg){
    try{ localStorage.setItem("ir_config", JSON.stringify(cfg)); }catch(_){}
  }

  let CFG = loadCfg();

  function applyCfgToUi(){
    const rt = document.getElementById("cfgRunThreshold");
    const sg = document.getElementById("cfgStripeGap");
    const sa = document.getElementById("cfgStripeShadowAlpha");
    const st = document.getElementById("cfgStrokeAlpha");
    if (rt) rt.value = String(CFG.runThreshold);
    if (sg) sg.value = String(CFG.stripeGap);
    if (sa) sa.value = String(CFG.stripeShadowAlpha);
    if (st) st.value = String(CFG.strokeAlpha);
  }

  function readCfgFromUi(){
    const rt = Number(document.getElementById("cfgRunThreshold")?.value || DEFAULT_CFG.runThreshold);
    const sg = Number(document.getElementById("cfgStripeGap")?.value || DEFAULT_CFG.stripeGap);
    const sa = Number(document.getElementById("cfgStripeShadowAlpha")?.value || DEFAULT_CFG.stripeShadowAlpha);
    const st = Number(document.getElementById("cfgStrokeAlpha")?.value || DEFAULT_CFG.strokeAlpha);
    return {
      runThreshold: Math.max(2, Math.min(30, Math.round(rt))),
      stripeGap: Math.max(0, Math.min(30, Math.round(sg))),
      stripeShadowAlpha: Math.max(0, Math.min(1, Number(sa.toFixed(2)))),
      strokeAlpha: Math.max(0, Math.min(1, Number(st.toFixed(2))))
    };
  }

  const UNDO_STACK = [];

  function pushUndo(action){
    UNDO_STACK.push(action);
    if (UNDO_STACK.length > 200) UNDO_STACK.shift();
    const b = document.getElementById("undo");
    if (b) b.disabled = UNDO_STACK.length === 0;
  }

  function setUndoEnabled(){
    const b = document.getElementById("undo");
    if (b) b.disabled = UNDO_STACK.length === 0;
  }


  function postOverlayEvent({title, line, color=TEAM_COLOR, ttlMs=2500}) {
    fetch(API + "/api/overlay_event", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ title, line, color, ttlMs })
    }).catch(()=>{});
  }

  function checkAndPostMilestone(name, pts){
    const mil = Math.floor((pts || 0) / 10);
    const reached = MILESTONE_REACHED[name] || 0;
    if (mil > reached && mil > 0){
      MILESTONE_REACHED[name] = mil;
      postOverlayEvent({ title: name, line: `${mil*10} points`, ttlMs: 2500 });
    }
  }

  async function postCareerFtIfAvailable(name){
    try{
      const r = await fetch(API + "/api/player_career_ft?name=" + encodeURIComponent(name), { cache: "no-store" });
      if (!r.ok) return;
      const j = await r.json();
      if (j.pct === null || j.pct === undefined) return;
      postOverlayEvent({ title: name, line: `CAREER FT%: ${j.pct}%`, ttlMs: 4500 });
    }catch(_){}
  }

  const POP_STATE = {
    prevTeam: null,
    prevOpp: null,

    teamRunPts: 0,
    oppRunPts: 0,
    lastTeamRunShown: 0,
    lastOppRunShown: 0,

    bursts: {},
    lastBurstShown: {},
    makeStreak: {},
    lastStreakShown: {},
    teamShots: [],
    lastTeamShootShown: "",
    flags: {}
  };

  // snapshot/restore popup state so undo also rewinds streaks/runs
  function snapPopState(){
    try { return JSON.parse(JSON.stringify(POP_STATE)); }
    catch(_){ return null; }
  }
  function restorePopState(s){
    if (!s) return;
    // replace all keys to match snapshot exactly
    for (const k of Object.keys(POP_STATE)){ delete POP_STATE[k]; }
    for (const k of Object.keys(s)){ POP_STATE[k] = s[k]; }
  }



  function playerColor(name){
    return COLOR_MAP[name] || TEAM_COLOR;
  }

  // fires once per (player + key). persists until you clear it.
const ONCE_FLAGS = new Map(); // name -> Set(keys)

function flagOnce(name, key){
  let s = ONCE_FLAGS.get(name);
  if (!s){
    s = new Set();
    ONCE_FLAGS.set(name, s);
  }
  if (s.has(key)) return false;
  s.add(key);
  return true;
}

// optional: call this when you start a new game
function resetOnceFlags(){
  ONCE_FLAGS.clear();
}


  function maybeRunPopup(teamNow, oppNow){
    const oppName = (document.getElementById("opp")?.value || "opp").trim() || "opp";
    const oppColor = document.getElementById("oppColor")?.value || "#4B5563";
    const thr = CFG.runThreshold || 6;

    if (POP_STATE.prevTeam === null || POP_STATE.prevOpp === null){
      POP_STATE.prevTeam = teamNow;
      POP_STATE.prevOpp = oppNow;
      POP_STATE.teamRunPts = 0;
      POP_STATE.oppRunPts = 0;
      return;
    }

    // team run: team increases while opp stays the same
    if (oppNow !== POP_STATE.prevOpp){
      POP_STATE.teamRunPts = 0;
    }
    const incTeam = teamNow - POP_STATE.prevTeam;
    if (oppNow === POP_STATE.prevOpp && incTeam > 0){
      POP_STATE.teamRunPts += incTeam;
    }

    // opp run: opp increases while team stays the same
    if (teamNow !== POP_STATE.prevTeam){
      POP_STATE.oppRunPts = 0;
    }
    const incOpp = oppNow - POP_STATE.prevOpp;
    if (teamNow === POP_STATE.prevTeam && incOpp > 0){
      POP_STATE.oppRunPts += incOpp;
    }

    POP_STATE.prevTeam = teamNow;
    POP_STATE.prevOpp = oppNow;

    if (POP_STATE.teamRunPts >= thr && POP_STATE.teamRunPts !== POP_STATE.lastTeamRunShown){
      POP_STATE.lastTeamRunShown = POP_STATE.teamRunPts;
      postOverlayEvent({
        title: "inj",
        line: `${POP_STATE.teamRunPts}–0 run`,
        color: TEAM_COLOR,
        ttlMs: 2400
      });
    }

    if (POP_STATE.oppRunPts >= thr && POP_STATE.oppRunPts !== POP_STATE.lastOppRunShown){
      POP_STATE.lastOppRunShown = POP_STATE.oppRunPts;
      postOverlayEvent({
        title: oppName,
        line: `${POP_STATE.oppRunPts}–0 run`,
        color: oppColor,
        ttlMs: 2400
      });
    }
  }


  function recordShotForTeam(made){ /* disabled */ }

  function recordMakeForPlayer(name, ptsDelta){
    const now = Date.now();
    const arr = (POP_STATE.bursts[name] ||= []);
    arr.push({ ts: now, pts: ptsDelta });
    const cutoff = now - 90_000;
    while (arr.length && arr[0].ts < cutoff) arr.shift();
    const sum = arr.reduce((a,e)=>a+e.pts,0);

    if (sum >= 6){
      const last = POP_STATE.lastBurstShown[name] || 0;
      if (now - last > 30_000){
        POP_STATE.lastBurstShown[name] = now;
        postOverlayEvent({
          title: name,
          line: `${sum} points (last 90s)`,
          color: playerColor(name),
          ttlMs: 2400
        });
      }
    }

    POP_STATE.makeStreak[name] = (POP_STATE.makeStreak[name] || 0) + 1;
    const streak = POP_STATE.makeStreak[name];
    if (streak >= 3){
      const shown = POP_STATE.lastStreakShown[name] || 0;
      if (streak > shown){
        POP_STATE.lastStreakShown[name] = streak;
        postOverlayEvent({
          title: name,
          line: `${streak} straight makes`,
          color: playerColor(name),
          ttlMs: 2200
        });
      }
    }
  }

  function recordMissForPlayer(name){
    POP_STATE.makeStreak[name] = 0;
  }

  function checkOtherMilestones(p){
  const name = p.NAMES;

  const pts = Number(p.PTS || 0);
  const reb = Number(p.REB || 0);
  const ast = Number(p.AST || 0);
  const stl = Number(p.STL || 0);
  const blk = Number(p.BLK || 0);

  const fls = Number(p.FLS || 0);
  if (fls >= 3 && flagOnce(name,"fls",3)) postOverlayEvent({ title: name, line: "3 FOULS", color: playerColor(name), ttlMs: 2200 });
  if (fls >= 4 && flagOnce(name,"fls",4)) postOverlayEvent({ title: name, line: "4 FOULS", color: playerColor(name), ttlMs: 2200 });
  if (fls >= 5 && flagOnce(name,"fls",5)) postOverlayEvent({ title: name, line: "5 FOULS FOULED OUT", color: playerColor(name), ttlMs: 2400 });


  const M = [
    { k: "PTS", v: pts, start: 5, step: 5, ttl: 2400 },
    { k: "REB", v: reb, start: 5, step: 5, ttl: 2400 },
    { k: "AST", v: ast, start: 5, step: 5, ttl: 2400 },
    { k: "STL", v: stl, start: 2,  step: 2, ttl: 2200 },
    { k: "BLK", v: blk, start: 2,  step: 2, ttl: 2200 },
  ];

  for (const m of M){
  if (m.v < m.start) continue;

  const t = m.start + Math.floor((m.v - m.start) / m.step) * m.step;

  // unique per threshold: "PTS_15", "STL_4", etc
  if (flagOnce(name, `${m.k}_${t}`)){
    postOverlayEvent({
      title: name,
      line: `${t} ${m.k}`,
      color: playerColor(name),
      ttlMs: m.ttl
    });
  }
}


  const order = [
    ["PTS", pts],
    ["REB", reb],
    ["AST", ast],
    ["STL", stl],
    ["BLK", blk],
  ];

  const doneStats  = order.filter(([k,v]) => v >= 10);
  const doneCount  = doneStats.length;
  const doneLine   = doneStats.map(([k,v]) => `${v} ${k}`).join(" ");

  if (doneCount >= 4 && flagOnce(name,"qd",1)){
    postOverlayEvent({ title: name, line: `QUADRUPLE-DOUBLE: ${doneLine}`, color: playerColor(name), ttlMs: 4500 });
  } else if (doneCount === 3 && flagOnce(name,"td",1)){
    postOverlayEvent({ title: name, line: `TRIPLE-DOUBLE: ${doneLine}`, color: playerColor(name), ttlMs: 4500 });
  } else if (doneCount === 2 && flagOnce(name,"dd",1)){
    postOverlayEvent({ title: name, line: `DOUBLE-DOUBLE: ${doneLine}`, color: playerColor(name), ttlMs: 4500 });
  }else if (doneCount === 5 && flagOnce(name,"qid",1)) {
    postOverlayEvent({title: name, line: `QUINTUPLE-DOUBLE: ${doneLine}`, color: playerColor(name), ttlMs: 4500});
  }

}


  function pushLiveScore() {
    let team = 0;
    state.players.forEach(p => team += p.PTS || 0);

    const opp = Number(document.getElementById("oppScore").value || 0);
    const period = document.getElementById("period").value;

    maybeRunPopup(team, opp);

    const s1 = document.getElementById("oppStripe1")?.value || "#ffffff";
    const s2 = document.getElementById("oppStripe2")?.value || "#9CA3AF";

    fetch(API + "/api/live_score", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({
        home: team,
        away: opp,
        opp: document.getElementById("opp").value || "OPP",     // full name goes through
        oppColor: document.getElementById("oppColor").value || "#4B5563",
        period: period,
        oppStripe1: s1,
        oppStripe2: s2,
        stripeGap: CFG.stripeGap,
        stripeShadowAlpha: CFG.stripeShadowAlpha,
        strokeAlpha: CFG.strokeAlpha
      })
    }).catch(()=>{});

    // keep endgame screen in sync while you click stats
    pushEndgameState();
  }

  function calcTeamTotals(players){
    const t = {
      "2PM":0,"2PA":0,"3PM":0,"3PA":0,
      FTM:0,FTA:0,OREB:0,DREB:0,
      AST:0,STL:0,BLK:0,TOV:0,FLS:0,
      FGM:0,FGA:0,PTS:0,REB:0,
      "FG%":0,"3P%":0,"FT%":0,"TS%":0,
      GSC:0
    };

    for (const p of players){
      t["2PM"] += p["2PM"]||0; t["2PA"] += p["2PA"]||0;
      t["3PM"] += p["3PM"]||0; t["3PA"] += p["3PA"]||0;
      t.FTM += p.FTM||0; t.FTA += p.FTA||0;
      t.OREB += p.OREB||0; t.DREB += p.DREB||0;
      t.AST += p.AST||0; t.STL += p.STL||0; t.BLK += p.BLK||0;
      t.TOV += p.TOV||0; t.FLS += p.FLS||0;
      t.FGM += p.FGM||0; t.FGA += p.FGA||0;
      t.REB += p.REB||0; t.PTS += p.PTS||0;
      t.GSC += p.GSC||0;
    }

    t["FG%"] = t.FGA ? (t.FGM / t.FGA) : 0;
    t["3P%"] = t["3PA"] ? (t["3PM"] / t["3PA"]) : 0;
    t["FT%"] = t.FTA ? (t.FTM / t.FTA) : 0;
    const denom = 2 * (t.FGA + 0.44 * t.FTA);
    t["TS%"] = denom ? (t.PTS / denom) : 0;

    return t;
  }

  function pushEndgameState(){
    try{
      const season = Number(document.getElementById("season").value || 0);
      const game = Number(document.getElementById("game").value || 0);
      const opp = (document.getElementById("opp").value || "OPP").toString().trim();
      const type = (document.getElementById("type").value || "REG").toString().trim();
      const oppScore = Number(document.getElementById("oppScore").value || 0);
      const oppColor = (document.getElementById("oppColor").value || "#4B5563").toString().trim();


const players = state.players.map(p => {
  const d = derive({...p});
  const gp = GAME.players[p.NAMES] || { seconds: 0, plusMinus: 0 };

  return {
    ...d,
    minutes: getLiveSeconds(p.NAMES),   // ← THIS is the fix
    plusMinus: gp.plusMinus
  };
});



      const injScore = players.reduce((a,p)=>a+(p.PTS||0),0);
      const teamTotals = calcTeamTotals(players);

      const payload = {
        injColor: TEAM_COLOR,
        oppColor: oppColor,
        final: { inj: injScore, opp: oppScore },
        meta: { season: season || "-", game: game || "-", opp: opp || "-", type: type || "-" },
        teamTotals: teamTotals,
        players: players,
        playerColors: COLOR_MAP
      };

      fetch(API + "/api/endgame_state", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ state: payload })
      }).catch(()=>{});
    }catch(_){}
  }

  const EDITABLE = [
    ["2PM","2pm"], ["2PA","2pa"], ["3PM","3pm"], ["3PA","3pa"],
    ["FTM","ftm"], ["FTA","fta"],
    ["OREB","oreb"], ["DREB","dreb"],
    ["AST","ast"], ["STL","stl"], ["BLK","blk"],
    ["TOV","tov"], ["FLS","fls"]
  ];

  function resetGame() {
  // reset opp score input
  document.getElementById("oppScore").value = "0";

  // reset all players' editable stats (team score derives from these)
  state.players.forEach(p => {
    for (const [k] of EDITABLE) p[k] = 0;
    derive(p);
  });

  // reset minutes + plus minus
GAME.clockSec = 1200;
GAME.running = false;
clearInterval(clockInterval);
GAME.lineup.clear();
GAME.players = {};


  // reset milestone + popup/run tracking
  for (const k in MILESTONE_REACHED) delete MILESTONE_REACHED[k];

  POP_STATE.prevTeam = null;
  POP_STATE.prevOpp = null;
  POP_STATE.teamRunPts = 0;
  POP_STATE.oppRunPts = 0;
  POP_STATE.lastTeamRunShown = 0;
  POP_STATE.lastOppRunShown = 0;

  POP_STATE.bursts = {};
  POP_STATE.lastBurstShown = {};
  POP_STATE.makeStreak = {};
  POP_STATE.lastStreakShown = {};
  POP_STATE.teamShots = [];
  POP_STATE.lastTeamShootShown = "";
  POP_STATE.flags = {};

  // clear undo history too (reset is a hard reset)
  UNDO_STACK.length = 0;
  setUndoEnabled();

  renderRows();
  pushLiveScore();

  showMsg("reset: scores + popups cleared");
}


document.getElementById("reset").onclick = (e) => {
  e.preventDefault();
  resetGame();
};


  const clamp0 = (n) => Math.max(0, n|0);

  function pct(m, a) { return a ? (m / a) : 0; }

  function calcGSC(p) {
    const PTS = p.PTS, FG = p.FGM, FGA = p.FGA, FT = p.FTM, FTA = p.FTA;
    const ORB = p.OREB, DRB = p.DREB, STL = p.STL, AST = p.AST, BLK = p.BLK;
    const PF = p.FLS, TOV = p.TOV;
    return (
      PTS + 0.4*FG - 0.7*FGA - 0.4*(FTA-FT) + 0.7*ORB + 0.3*DRB + STL +
      0.7*AST + 0.7*BLK - 0.4*PF - TOV
    );
  }

  function derive(p) {
    for (const [k] of EDITABLE) p[k] = clamp0(p[k] || 0);

    p.FGM = p["2PM"] + p["3PM"];
    p.FGA = p["2PA"] + p["3PA"];
    p.REB = p.OREB + p.DREB;
    p.PTS = 2*p["2PM"] + 3*p["3PM"] + p.FTM;

    p["2P%"] = pct(p["2PM"], p["2PA"]);
    p["3P%"] = pct(p["3PM"], p["3PA"]);
    p["FT%"] = pct(p.FTM, p.FTA);
    p["FG%"] = pct(p.FGM, p.FGA);
    const denom = 2 * (p.FGA + 0.44 * p.FTA);
    p["TS%"] = denom ? (p.PTS / denom) : 0;

    p.GSC = calcGSC(p);
    return p;
  }

  function newPlayer(name) {
    return derive({
      NAMES: name,
      "2PM":0,"2PA":0,"3PM":0,"3PA":0,
      FTM:0,FTA:0, OREB:0,DREB:0,
      AST:0,STL:0,BLK:0,TOV:0,FLS:0,
      FGM:0,FGA:0,PTS:0,REB:0,
      "FG%":0,"TS%":0,"FT%":0,"2P%":0,"3P%":0,
      GSC:0
    });
  }

  let state = { players: [] };

  // =============================
// LINEUP / MINUTES / +/- ENGINE
// =============================

let GAME = {
  clockSec: 1200,       // 20:00 half
  running: false,
  lineup: new Set(),    // players currently on court
  players: {}           // per-player tracking
};

function ensureGamePlayer(name){
  if (!GAME.players[name]){
    GAME.players[name] = {
      seconds: 0,
      plusMinus: 0,
      lastIn: null
    };
  }
}

function formatTime(sec){
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${String(s).padStart(2,"0")}`;
}

function getLiveSeconds(name){
  const p = GAME.players[name];
  if (!p) return 0;

  if (GAME.lineup.has(name)){
    return p.seconds + (p.lastIn - GAME.clockSec);
  }
  return p.seconds;
}

function subIn(name){
  ensureGamePlayer(name);

  if (GAME.lineup.has(name)) return;
  if (GAME.lineup.size >= 5){
    alert("5 players already on court");
    return;
  }

  GAME.lineup.add(name);
  GAME.players[name].lastIn = GAME.clockSec;
  renderRows();
}

function subOut(name){
  if (!GAME.lineup.has(name)) return;

  const p = GAME.players[name];
  p.seconds += (p.lastIn - GAME.clockSec);
  p.lastIn = null;

  GAME.lineup.delete(name);
  renderRows();
}

function applyTeamScore(points){
  for (let name of GAME.lineup){
    ensureGamePlayer(name);
    GAME.players[name].plusMinus += points;
  }
}

function applyOppScore(points){
  for (let name of GAME.lineup){
    ensureGamePlayer(name);
    GAME.players[name].plusMinus -= points;
  }
}

let clockInterval = null;

function updateClockButtons(){
  const start = document.getElementById("startBtn");
  const stop  = document.getElementById("stopBtn");

  if (!start || !stop) return;

  start.classList.remove("active");
  stop.classList.remove("stopActive");

  if (GAME.running){
    start.classList.add("active");
  } else {
    stop.classList.add("stopActive");
  }
}


function startClock(){
  if (GAME.running) return;
  GAME.running = true;
  updateClockButtons();

  clockInterval = setInterval(() => {
    if (GAME.clockSec <= 0){
      stopClock();
      return;
    }
    GAME.clockSec--;
    renderRows();
    pushEndgameState();
  }, 1000);
}


function stopClock(){
  GAME.running = false;
  clearInterval(clockInterval);
  updateClockButtons();
}



  function showMsg(s, ok=true) {
    const el = document.getElementById("msg");
    el.style.display = "block";
    el.textContent = s;
    el.className = "msg" + (ok ? "" : " danger");
  }

  function renderHeader() {
    const head = document.getElementById("thead");
    head.innerHTML = "";

    const thName = document.createElement("div");
    thName.className = "th";
    thName.textContent = "player";
    head.appendChild(thName);

    for (const [,label] of EDITABLE) {
      const th = document.createElement("div");
      th.className = "th";
      th.textContent = label;
      head.appendChild(th);
    }

    const thMin = document.createElement("div");
thMin.className = "th";
thMin.textContent = "min";
head.appendChild(thMin);


const thLineup = document.createElement("div");
thLineup.className = "th";
thLineup.textContent = "lineup";
head.appendChild(thLineup);



    const thRemove = document.createElement("div");
    thRemove.className = "th";
    thRemove.textContent = "";
    head.appendChild(thRemove);
  }

  function getInitials(name){
  return name
    .split(" ")
    .map(n => n[0])
    .join("")
    .toUpperCase();
}


  function renderRows() {
    const body = document.getElementById("tbody");
    body.innerHTML = "";

    state.players.forEach((p, idx) => {
      derive(p);
      ensureGamePlayer(p.NAMES);


      const row = document.createElement("div");
      row.className = "trow";

      const name = document.createElement("div");
      name.className = "td namecell";

      const chip = document.createElement("div");
      chip.className = "chip";

      const c = COLOR_MAP[p.NAMES];
      if (c) row.style.setProperty("--rowcolor", c);
      if (c) {
        row.classList.add("hasColor");
        row.style.setProperty("--rowcolor", c);
        chip.style.background = c;
      } else {
        chip.style.background = "rgba(255,255,255,0.25)";
        chip.style.opacity = "0.8";
      }

      const label = document.createElement("div");
label.textContent = getInitials(p.NAMES);
label.title = p.NAMES; // full name on hover


      name.appendChild(chip);
      name.appendChild(label);
      row.appendChild(name);

      for (const [key,labelTxt] of EDITABLE) {
        const cell = document.createElement("div");
        cell.className = "td";

        const box = document.createElement("div");
        box.className = "statbox";

        box.onclick = async (e) => {
          const delta = e.shiftKey ? -1 : 1;

          pushUndo({ type: "stat", player: p.NAMES, key, delta, pop: snapPopState() });

          p[key] = clamp0((p[key] || 0) + delta);

          // auto-increment attempts when a make is added
if (delta === 1) {
  if (key === "2PM") p["2PA"] = clamp0((p["2PA"] || 0) + 1);
  if (key === "3PM") p["3PA"] = clamp0((p["3PA"] || 0) + 1);
  if (key === "FTM") p["FTA"] = clamp0((p["FTA"] || 0) + 1);
}


            if (delta === 1){
            if (key === "3PM"){
  recordMakeForPlayer(p.NAMES, 3);
  recordShotForTeam(true);
  applyTeamScore(3);
}

if (key === "FTM"){
  recordMakeForPlayer(p.NAMES, 1);
  applyTeamScore(1);
}

            if (key === "2PM"){
  recordMakeForPlayer(p.NAMES, 2);
  recordShotForTeam(true);
  applyTeamScore(2);
}
            }

          derive(p);


          renderRows();
          pushLiveScore();

          checkAndPostMilestone(p.NAMES, p.PTS || 0);
          checkOtherMilestones(p);

          if (delta === 1){
            if (key === "2PM"){ recordMakeForPlayer(p.NAMES, 2); recordShotForTeam(true); }
            if (key === "3PM"){ recordMakeForPlayer(p.NAMES, 3); recordShotForTeam(true); }
            if (key === "FTM"){ recordMakeForPlayer(p.NAMES, 1); }
            if (key === "2PA" || key === "3PA"){ recordMissForPlayer(p.NAMES); recordShotForTeam(false); }
          }

          if (key === "FTA" && delta === 1){
            await postCareerFtIfAvailable(p.NAMES);
          }
        };

        const l = document.createElement("div");
        l.className = "statlabel";
        l.textContent = labelTxt;

        const v = document.createElement("div");
        v.className = "statval";
        v.textContent = String(p[key] || 0);

        box.appendChild(l);
        box.appendChild(v);
        cell.appendChild(box);
        row.appendChild(cell);
      }
      // minutes
const minCell = document.createElement("div");
minCell.className = "td";
minCell.textContent = formatTime(getLiveSeconds(p.NAMES));
row.appendChild(minCell);


// lineup controls
const lineupCell = document.createElement("div");
lineupCell.className = "td";

const wrap = document.createElement("div");
wrap.className = "lineupControls";

const inBtn = document.createElement("button");
inBtn.textContent = "IN";
inBtn.className = "ghost smallbtn";

const outBtn = document.createElement("button");
outBtn.textContent = "OUT";
outBtn.className = "ghost smallbtn";

if (GAME.lineup.has(p.NAMES)){
  row.classList.add("active");
} else {
  outBtn.classList.add("outActive");
}

inBtn.onclick = () => subIn(p.NAMES);
outBtn.onclick = () => subOut(p.NAMES);

wrap.appendChild(inBtn);
wrap.appendChild(outBtn);
lineupCell.appendChild(wrap);

row.appendChild(lineupCell);

      // derived: gsc (read-only)

      const rm = document.createElement("div");
rm.className = "td";
rm.style.textAlign = "center";

const btn = document.createElement("button");
btn.className = "removeBtn";
btn.innerHTML = "&times;";
btn.title = "remove player";

      btn.onclick = () => {
        const removed = JSON.parse(JSON.stringify(p));
        const at = idx;
        state.players.splice(idx, 1);
        pushUndo({ type: "removePlayer", index: at, player: removed });
        renderRows();
        pushLiveScore();
      };

      rm.appendChild(btn);
      row.appendChild(rm);

      body.appendChild(row);
    });
  }

  function render() {
    renderHeader();
    renderRows();
  }

  function initPlayersDropdown() {
    const sel = document.getElementById("playerSelect");
    COMMON_PLAYERS.forEach(n => {
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    });
  }

  document.getElementById("addPlayer").onclick = () => {
    const sel = document.getElementById("playerSelect");
    const picked = sel.value.trim();
    const custom = document.getElementById("customName").value.trim();
    const name = custom || picked;

    if (!name) return;

    const exists = state.players.some(p => p.NAMES.toLowerCase() === name.toLowerCase());
    if (exists) {
      showMsg("player already added", false);
      return;
    }

    const newIdx = state.players.length;
    state.players.push(newPlayer(name));
    pushUndo({ type: "addPlayer", index: newIdx });
    document.getElementById("customName").value = "";
    sel.value = "";
    renderRows();
    pushLiveScore();
  };

  document.getElementById("save").onclick = async () => {
    const season = document.getElementById("season").value.trim();
    const game = document.getElementById("game").value.trim();
    const opp = document.getElementById("opp").value.trim();
    const type = document.getElementById("type").value;

    if (!season || !game || !opp) {
      showMsg("season/game/opp required", false);
      return;
    }
    if (!state.players.length) {
      showMsg("add at least one player", false);
      return;
    }


const players = state.players.map(p => {
  const d = derive({...p});
  const gp = GAME.players[p.NAMES] || { seconds: 0, plusMinus: 0 };

  return {
    ...d,
    minutes: getLiveSeconds(p.NAMES),  // ← include live running time
    plusMinus: gp.plusMinus
  };
});


    const oppScore = Number(document.getElementById("oppScore").value || 0);

    const payload = {
      meta: {
        season: Number(season),
        game: Number(game),
        opp,
        type,
        oppScore,
        oppColor: document.getElementById("oppColor").value || ""
      },
      players
    };

    try {
      const res = await fetch(API + "/api/save_game", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const js = await res.json();
      if (!res.ok) throw new Error(js.error || "save failed");
      showMsg(`saved: ${js.inserted} rows`);
    } catch (err) {
      showMsg(String(err), false);
    }
  };

  initPlayersDropdown();
  render();
  updateClockButtons();


  // undo
  function undoLast(){
    const a = UNDO_STACK.pop();
    setUndoEnabled();
    if (!a) return;

    restorePopState(a.pop);

    if (a.type === "stat"){
  const p = state.players.find(x => (x.NAMES || "").toLowerCase() === (a.player || "").toLowerCase());
  if (p){
    // undo the clicked stat
    p[a.key] = clamp0((p[a.key] || 0) - a.delta);

    // undo auto-attempts for makes (only if the original action was +1)
    if (a.delta === 1){
      if (a.key === "FTM") p["FTA"] = clamp0((p["FTA"] || 0) - 1);
      if (a.key === "2PM") p["2PA"] = clamp0((p["2PA"] || 0) - 1);
      if (a.key === "3PM") p["3PA"] = clamp0((p["3PA"] || 0) - 1);
    }

    derive(p);
  }
}

     else if (a.type === "oppScore"){
      document.getElementById("oppScore").value = String(a.prev ?? 0);
    } else if (a.type === "addPlayer"){
      const i = Number(a.index);
      if (!Number.isNaN(i) && state.players[i]) state.players.splice(i, 1);
    } else if (a.type === "removePlayer"){
      const i = Number(a.index);
      const pl = a.player;
      if (pl){
        const insertAt = (Number.isNaN(i) ? state.players.length : Math.max(0, Math.min(state.players.length, i)));
        state.players.splice(insertAt, 0, pl);
      }
    }

    renderRows();
    pushLiveScore();
  }

  document.getElementById("undo").addEventListener("click", (e) => {
    e.preventDefault();
    undoLast();
  });

  window.addEventListener("keydown", (e) => {
    if ((e.ctrlKey || e.metaKey) && (e.key === "z" || e.key === "Z")){
      e.preventDefault();
      undoLast();
    }
  });

  // load config once at startup
  applyCfgToUi();
  setUndoEnabled();


  document.getElementById("oppScore").addEventListener("input", pushLiveScore);
  document.getElementById("opp").addEventListener("input", pushLiveScore);
  document.getElementById("oppColor").addEventListener("input", pushLiveScore);
  document.getElementById("oppStripe1").addEventListener("input", pushLiveScore);
  document.getElementById("oppStripe2").addEventListener("input", pushLiveScore);
  document.getElementById("period").addEventListener("change", pushLiveScore);

document.querySelectorAll("[data-oppdelta]").forEach(btn => {
  btn.addEventListener("click", function(e){
    e.preventDefault();

    const d = Number(this.getAttribute("data-oppdelta") || 0);
    const inp = document.getElementById("oppScore");
    const cur = Number(inp.value || 0);
    const next = Math.max(0, cur + d);

    if (next !== cur){
      pushUndo({ type: "oppScore", prev: cur, next, pop: snapPopState() });
    }

    inp.value = String(next);

    if (d !== 0 && GAME.lineup.size > 0){
      applyOppScore(d);
    }

    pushLiveScore();
  });
});



</script>
</body>
</html>
